# 用户的金额引发的思考
有这么一种情景，当服务器延时，或者客户端网络慢的情况，还有就是恶意攻击；我们知道由于修改用户余额的操作是属于异步的，那么就有可能出现多次请求同时达到，再判断的时候用户的余额是大于0的，此时就会出现有很多请求同时经过这一道门槛，这样多次请求就会同时操作，导致用户的余额出现低于 0 的情况，甚至余额低出范围变成了最大数。
根据以上情况，需要解决的是当用户操作余额的时候，此时需要将操作锁定，只有当这次操作结束以后其他的请求才能继续执行下面的操作。
我这儿有三种解决方案：
## 第一种，使用 channel 的方式解决
这种方式就是传递一个 channel 进入操作中， channel 里面第一次需要存进去一个值，只要有人去操作，那么就会取走 channel 里面的值，此时不能再取值，后面的请求就只能先阻塞在那儿，等上一次操作完成以后才能继续，一次操作完成以后需要传进去一个值，这样下一个请求就能继续操作。
## 第二种，使用官方提供的 mutex ，也就是互斥锁
当进入操作后，第一步就锁上，操作完成以后再锁上。
~~~
lock.Lock()
defer lock.Unlock()
~~~
## 第三种，使用先做原则
也就是不管用户进行什么操作，只要用户开始操作，第一步就将金额数减出，真正操作的时候只需要判断是否大于或等于 0 即可。